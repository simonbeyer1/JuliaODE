## Autogenerated Julia Code by JuliaODEmodel --- 

# Loading necessary Julia packages 
using OrdinaryDiffEq, ForwardDiff

# Define the evolution function 
function LotkaVolterra!(du, u, p, t)
    du[1] = p[1] * u[1] - p[2] * u[1] * u[2]
    du[2] = p[3] * u[1] * u[2] - p[4] * u[2]
end 

# Julia functions for event handling 
condition_1(u, t, integrator) = integrator.t == 50
condition_2(u, t, integrator) = integrator.t == 100

affect_1!(integrator) = integrator.u[1] += 2 * integrator.u[1]
affect_2!(integrator) = integrator.u[2] = integrator.u[2] / 2

cb_1 = DiscreteCallback(condition_1, affect_1!, save_positions = (true, true)) 
cb_2 = DiscreteCallback(condition_2, affect_2!, save_positions = (true, true)) 
cbs = CallbackSet(cb_1, cb_2)
tstop_events = [50, 100]


# Function for solving the ODEs without sensitivities
function solve_LotkaVolterra(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)
    sol = solve(ODEProblem(LotkaVolterra!, (@view p[1:2]), (times[1], times[end]), (@view p[3:end])), solver, args...; saveat=times, kwargs...)
    return hcat(sol.t, Array(sol)')
end 

# Function for solving the ODEs with sensitivities
function solvesens_LotkaVolterra(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)
    sol = solve(ODEProblem(LotkaVolterra!, (@view p[1:2]), (times[1], times[end]), (@view p[3:end])), solver, args...; saveat=times, kwargs...)
    jac = reshape(ForwardDiff.jacobian(pars -> hcat(solve(ODEProblem(LotkaVolterra!, (@view pars[1:2]), (times[1], times[end]), (@view pars[3:end])), solver, args...; saveat=times, kwargs...).u...)', p), length(sol.t), :)
    return hcat(sol.t, Array(sol)', jac)
end 


