## Autogenerated Julia Code by JuliaODE --- 

# Loading necessary Julia packages 
using OrdinaryDiffEq, ForwardDiff

# Define the evolution function 
function reaction_model!(du, u, p, t)
    du[1] = -p[1] * u[1] * t
    du[2] = p[1] * u[1] - p[2] * u[2]
end 

# Julia functions for event handling 
condition_1(u, t, integrator) = t == 50
condition_2(u, t, integrator) = t == 70

affect_1!(integrator) = integrator.u[1] += 0.5
affect_2!(integrator) = integrator.u[2] = 0

cb_1 = DiscreteCallback(condition_1, affect_1!, save_positions = (true, true)) 
cb_2 = DiscreteCallback(condition_2, affect_2!, save_positions = (true, true)) 
cbs = CallbackSet(cb_1, cb_2)
tstop_events = [50, 70]


# Function for solving the ODEs without sensitivities
function solve_reaction_model(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)
    sol = solve(ODEProblem(reaction_model!, (@view p[1:2]), (times[1], times[end]), (@view p[3:end)), solver, args...; saveat=times, kwargs...)
    return hcat(sol.t, Array(sol)')
end 

# Function for solving the ODEs with sensitivities
function solvesens_reaction_model(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)
    sol = solve(ODEProblem(reaction_model!, (@view p[1:2]), (times[1], times[end]), (@view p[3:end)), solver, args...; saveat=times, kwargs...)
    jac = reshape(ForwardDiff.jacobian(pars -> hcat(solve(ODEProblem(reaction_model!, (@view pars[1:2]), (times[1], times[end]), (@view pars[3:end)), solver, args...; saveat=times, kwargs...).u...)', p), length(sol.t), :)
    return hcat(sol.t, Array(sol)', jac)
end 


