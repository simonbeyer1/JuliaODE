symbols <- unique(unlist(lapply(odefunction, function(expr) {
parsed_expr <- parse(text = expr)
all.vars(parsed_expr)
})))
parameters <- setdiff(symbols, dynvars)
dynvars_indices <- stats::setNames(seq_along(dynvars), dynvars)
parameter_indices <- stats::setNames(seq_along(parameters), parameters)
eqncode <- lapply(odefunction, function(expr) {
for (x in dynvars) {
expr <- gsub(paste0("\\b", x, "\\b"), paste0("u[", dynvars_indices[x], "]"), expr)
}
for (pname in parameters) {
expr <- gsub(paste0("\\b", pname, "\\b"), paste0("p[", parameter_indices[pname], "]"), expr)
}
return(expr)
})
odefuncode <- paste0(
"# Define the evolution function \n",
"function ", modelname, "!(du, u, p, t)\n",
paste0("    du[", seq_along(dynvars), "] = ", eqncode, collapse = "\n"),
"\nend \n\n")
# Generate Julia code for events
if (!is.null(events)){
# Check for required columns in events
if (!all(c("var", "time", "value", "method") %in% colnames(events))) {
stop("The events dataframe must contain columns: 'var', 'time', 'value', 'method'.")
}
# Generate the julia functions code for condiutions and affects
affect_code <- NULL
condition_code <- NULL
cb_code <- NULL
for (row in seq_len(nrow(events))) {
var <- events$var[row]
time <- events$time[row]
value <- events$value[row]
method <- events$method[row]
condition_code <- paste0(condition_code, "condition_", as.character(row),"(u, t, integrator) = t == ", as.character(time), "\n")
# Map method to corresponding operation
operation_code <- switch(
method,
add = paste0("integrator.u[", dynvars_indices[var], "] += ", as.character(value)),
mult = paste0("integrator.u[", dynvars_indices[var], "] *= ", as.character(value)),
rep = paste0("integrator.u[", dynvars_indices[var], "] = ", as.character(value)),
stop(paste("Unsupported method:", method))
)
# Add the condition-specific operation
affect_code <- paste0(affect_code ,"affect_", as.character(row),"!(integrator) = ", operation_code, "\n")
cb_code <- paste0(cb_code,"cb_", as.character(row)," = DiscreteCallback(condition_", as.character(row),", affect_", as.character(row),"!, save_positions = (true, true)) \n")
}
cb_code <- paste0(cb_code,"cbs = CallbackSet(",paste0("cb_", seq_along(events$time), collapse = ", "), ")")
event_code <- paste0(
"# Julia functions for event handling \n",
condition_code, "\n",
affect_code, "\n",
cb_code, "\n",
"tstop_events = ", paste0("[", paste(unique(events$time), collapse = ", "), "]"), "\n"
)
} else{
event_code <- paste0("# Julia functions for event handling \n",
"cbs = nothing \n",
"tstop_events = nothing \n\n")
}
julia_code <- paste0(
"## Autogenerated Julia Code by JuliaODE --- \n\n",
"# Loading necessary julia packages \n",
"using OrdinaryDiffEq, ForwardDiff\n\n",
odefuncode, event_code,"\n\n",
"# Function for solving the ODEs without sensitivities\n",
"function solve_", modelname,"(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)\n",
"    sol = solve(ODEProblem(", modelname, "!, (@view p[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view p[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...)\n",
"    return hcat(sol.t, Array(sol.u)')\n",
"end \n\n",
"# Function for solving the ODEs with sensitivities\n",
"function solvesens_", modelname,"(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)\n",
"    sol = solve(ODEProblem(", modelname, "!, (@view p[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view p[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...)\n",
"    jac = reshape(ForwardDiff.jacobian(pars -> hcat(solve(ODEProblem(", modelname, "!, (@view pars[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view pars[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...).u...)', p),length(sol.t), :)\n",
"    return hcat(sol.t, Array(sol.u)',jac)\n",
"end \n\n"
)
# Save the generated Julia code to the specified file and source the code
writeLines(julia_code, file)
JuliaConnectoR::juliaEval(julia_code)
ODEmodel <- NULL
ODEmodel$solve <- function(x0, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6) {
# Integrate in Julia
out <- JuliaConnectoR::juliaLet(
paste0("solve_", modelname,"([x0;dynpars], times, ", solver, "; callback = cbs, tstops = tstop_events, abstol = atol, reltol = rtol)"),
x0 = x0, dynpars = dynpars, times = times, atol = atol, rtol = rtol
)
colnames(out) <- c("time", dynvars)
return(out)
}
ODEmodel$senssolve <- function(x0, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6) {
# Calculate Jacobian in Julia
out <- JuliaConnectoR::juliaLet(
paste0("solvesens_", modelname,"([x0;dynpars], times, ", solver, "; callback = cbs, tstops = tstop_events, abstol = atol, reltol = rtol)"),
x0 = x0, dynpars = dynpars, times = times, atol = atol, rtol = rtol
)
# Generate column names for the Jacobian
param_names <- c(dynvars, parameters)
jac_colnames <- c("time",dynvars, as.vector(outer(dynvars, param_names, paste, sep = ".")))
colnames(out) <- jac_colnames
return(out)
}
attr(ODEmodel, "equations") <- odefunction
attr(ODEmodel, "variables") <- dynvars
attr(ODEmodel, "parameters") <- parameters
attr(ODEmodel, "events") <- events
attr(ODEmodel, "modelname") <- modelname
attr(ODEmodel, "juliacode") <- julia_code
return(ODEmodel)
}
setwd("/home/simon/Documents/Projekte/test_juliaode")
# Define an example ODE system (A -> B -> 0) with rates k1 and k2
odefunction <- list(
A = "-k1 * A",
B = "k1 * A - k2 * B"
)
events <- data.frame(var = c("A", "B"), time = c(50, 70), value = c(0.5, 0), method = c("add", "rep"))
# Generate the Julia model
odemodel <- juliaODEmodel(odefunction, modelname = "reaction_model")
# Initial conditions and parameters
inits <- c(A = 1, B = 0)
params <- c(k1 = 0.2, k2 = 0.1)
times <- seq(0, 100, length.out = 300)
# Solve the ODE system
out <- odemodel$solve(inits, params, times)
#' times <- seq(0, 100, length.out = 300)
#'
#' # Solve the ODE system
#' out <- odemodel$solve(inits, params, times)
#' jac <- odemodel$getJac(inits, params, times)
#'
#' head(out)
#' heat(jac)
#'
#' @export
juliaODEmodel <- function(odefunction, modelname = "odemodel", file = paste0(modelname, ".jl"), events = NULL) {
# Generate Julia code for the ODE model function
dynvars <- names(odefunction)
symbols <- unique(unlist(lapply(odefunction, function(expr) {
parsed_expr <- parse(text = expr)
all.vars(parsed_expr)
})))
parameters <- setdiff(symbols, dynvars)
dynvars_indices <- stats::setNames(seq_along(dynvars), dynvars)
parameter_indices <- stats::setNames(seq_along(parameters), parameters)
eqncode <- lapply(odefunction, function(expr) {
for (x in dynvars) {
expr <- gsub(paste0("\\b", x, "\\b"), paste0("u[", dynvars_indices[x], "]"), expr)
}
for (pname in parameters) {
expr <- gsub(paste0("\\b", pname, "\\b"), paste0("p[", parameter_indices[pname], "]"), expr)
}
return(expr)
})
odefuncode <- paste0(
"# Define the evolution function \n",
"function ", modelname, "!(du, u, p, t)\n",
paste0("    du[", seq_along(dynvars), "] = ", eqncode, collapse = "\n"),
"\nend \n\n")
# Generate Julia code for events
if (!is.null(events)){
# Check for required columns in events
if (!all(c("var", "time", "value", "method") %in% colnames(events))) {
stop("The events dataframe must contain columns: 'var', 'time', 'value', 'method'.")
}
# Generate the julia functions code for condiutions and affects
affect_code <- NULL
condition_code <- NULL
cb_code <- NULL
for (row in seq_len(nrow(events))) {
var <- events$var[row]
time <- events$time[row]
value <- events$value[row]
method <- events$method[row]
condition_code <- paste0(condition_code, "condition_", as.character(row),"(u, t, integrator) = t == ", as.character(time), "\n")
# Map method to corresponding operation
operation_code <- switch(
method,
add = paste0("integrator.u[", dynvars_indices[var], "] += ", as.character(value)),
mult = paste0("integrator.u[", dynvars_indices[var], "] *= ", as.character(value)),
rep = paste0("integrator.u[", dynvars_indices[var], "] = ", as.character(value)),
stop(paste("Unsupported method:", method))
)
# Add the condition-specific operation
affect_code <- paste0(affect_code ,"affect_", as.character(row),"!(integrator) = ", operation_code, "\n")
cb_code <- paste0(cb_code,"cb_", as.character(row)," = DiscreteCallback(condition_", as.character(row),", affect_", as.character(row),"!, save_positions = (true, true)) \n")
}
cb_code <- paste0(cb_code,"cbs = CallbackSet(",paste0("cb_", seq_along(events$time), collapse = ", "), ")")
event_code <- paste0(
"# Julia functions for event handling \n",
condition_code, "\n",
affect_code, "\n",
cb_code, "\n",
"tstop_events = ", paste0("[", paste(unique(events$time), collapse = ", "), "]"), "\n"
)
} else{
event_code <- paste0("# Julia functions for event handling \n",
"cbs = nothing \n",
"tstop_events = nothing \n\n")
}
julia_code <- paste0(
"## Autogenerated Julia Code by JuliaODE --- \n\n",
"# Loading necessary julia packages \n",
"using OrdinaryDiffEq, ForwardDiff\n\n",
odefuncode, event_code,"\n\n",
"# Function for solving the ODEs without sensitivities\n",
"function solve_", modelname,"(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)\n",
"    sol = solve(ODEProblem(", modelname, "!, (@view p[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view p[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...)\n",
"    return hcat(sol.t, Array(sol)')\n",
"end \n\n",
"# Function for solving the ODEs with sensitivities\n",
"function solvesens_", modelname,"(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)\n",
"    sol = solve(ODEProblem(", modelname, "!, (@view p[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view p[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...)\n",
"    jac = reshape(ForwardDiff.jacobian(pars -> hcat(solve(ODEProblem(", modelname, "!, (@view pars[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view pars[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...).u...)', p),length(sol.t), :)\n",
"    return hcat(sol.t, Array(sol)',jac)\n",
"end \n\n"
)
# Save the generated Julia code to the specified file and source the code
writeLines(julia_code, file)
JuliaConnectoR::juliaEval(julia_code)
ODEmodel <- NULL
ODEmodel$solve <- function(x0, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6) {
# Integrate in Julia
out <- JuliaConnectoR::juliaLet(
paste0("solve_", modelname,"([x0;dynpars], times, ", solver, "; callback = cbs, tstops = tstop_events, abstol = atol, reltol = rtol)"),
x0 = x0, dynpars = dynpars, times = times, atol = atol, rtol = rtol
)
colnames(out) <- c("time", dynvars)
return(out)
}
ODEmodel$senssolve <- function(x0, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6) {
# Calculate Jacobian in Julia
out <- JuliaConnectoR::juliaLet(
paste0("solvesens_", modelname,"([x0;dynpars], times, ", solver, "; callback = cbs, tstops = tstop_events, abstol = atol, reltol = rtol)"),
x0 = x0, dynpars = dynpars, times = times, atol = atol, rtol = rtol
)
# Generate column names for the Jacobian
param_names <- c(dynvars, parameters)
jac_colnames <- c("time",dynvars, as.vector(outer(dynvars, param_names, paste, sep = ".")))
colnames(out) <- jac_colnames
return(out)
}
attr(ODEmodel, "equations") <- odefunction
attr(ODEmodel, "variables") <- dynvars
attr(ODEmodel, "parameters") <- parameters
attr(ODEmodel, "events") <- events
attr(ODEmodel, "modelname") <- modelname
attr(ODEmodel, "juliacode") <- julia_code
return(ODEmodel)
}
# Generate the Julia model
odemodel <- juliaODEmodel(odefunction, modelname = "reaction_model")
# Initial conditions and parameters
inits <- c(A = 1, B = 0)
params <- c(k1 = 0.2, k2 = 0.1)
times <- seq(0, 100, length.out = 300)
# Solve the ODE system
out <- odemodel$solve(inits, params, times)
out_sens <- odemodel$solvesens(inits, params, times)
#' times <- seq(0, 100, length.out = 300)
#'
#' # Solve the ODE system
#' out <- odemodel$solve(inits, params, times)
#' jac <- odemodel$getJac(inits, params, times)
#'
#' head(out)
#' heat(jac)
#'
#' @export
juliaODEmodel <- function(odefunction, modelname = "odemodel", file = paste0(modelname, ".jl"), events = NULL) {
# Generate Julia code for the ODE model function
dynvars <- names(odefunction)
symbols <- unique(unlist(lapply(odefunction, function(expr) {
parsed_expr <- parse(text = expr)
all.vars(parsed_expr)
})))
parameters <- setdiff(symbols, dynvars)
dynvars_indices <- stats::setNames(seq_along(dynvars), dynvars)
parameter_indices <- stats::setNames(seq_along(parameters), parameters)
eqncode <- lapply(odefunction, function(expr) {
for (x in dynvars) {
expr <- gsub(paste0("\\b", x, "\\b"), paste0("u[", dynvars_indices[x], "]"), expr)
}
for (pname in parameters) {
expr <- gsub(paste0("\\b", pname, "\\b"), paste0("p[", parameter_indices[pname], "]"), expr)
}
return(expr)
})
odefuncode <- paste0(
"# Define the evolution function \n",
"function ", modelname, "!(du, u, p, t)\n",
paste0("    du[", seq_along(dynvars), "] = ", eqncode, collapse = "\n"),
"\nend \n\n")
# Generate Julia code for events
if (!is.null(events)){
# Check for required columns in events
if (!all(c("var", "time", "value", "method") %in% colnames(events))) {
stop("The events dataframe must contain columns: 'var', 'time', 'value', 'method'.")
}
# Generate the julia functions code for condiutions and affects
affect_code <- NULL
condition_code <- NULL
cb_code <- NULL
for (row in seq_len(nrow(events))) {
var <- events$var[row]
time <- events$time[row]
value <- events$value[row]
method <- events$method[row]
condition_code <- paste0(condition_code, "condition_", as.character(row),"(u, t, integrator) = t == ", as.character(time), "\n")
# Map method to corresponding operation
operation_code <- switch(
method,
add = paste0("integrator.u[", dynvars_indices[var], "] += ", as.character(value)),
mult = paste0("integrator.u[", dynvars_indices[var], "] *= ", as.character(value)),
rep = paste0("integrator.u[", dynvars_indices[var], "] = ", as.character(value)),
stop(paste("Unsupported method:", method))
)
# Add the condition-specific operation
affect_code <- paste0(affect_code ,"affect_", as.character(row),"!(integrator) = ", operation_code, "\n")
cb_code <- paste0(cb_code,"cb_", as.character(row)," = DiscreteCallback(condition_", as.character(row),", affect_", as.character(row),"!, save_positions = (true, true)) \n")
}
cb_code <- paste0(cb_code,"cbs = CallbackSet(",paste0("cb_", seq_along(events$time), collapse = ", "), ")")
event_code <- paste0(
"# Julia functions for event handling \n",
condition_code, "\n",
affect_code, "\n",
cb_code, "\n",
"tstop_events = ", paste0("[", paste(unique(events$time), collapse = ", "), "]"), "\n"
)
} else{
event_code <- paste0("# Julia functions for event handling \n",
"cbs = nothing \n",
"tstop_events = nothing \n\n")
}
julia_code <- paste0(
"## Autogenerated Julia Code by JuliaODE --- \n\n",
"# Loading necessary julia packages \n",
"using OrdinaryDiffEq, ForwardDiff\n\n",
odefuncode, event_code,"\n\n",
"# Function for solving the ODEs without sensitivities\n",
"function solve_", modelname,"(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)\n",
"    sol = solve(ODEProblem(", modelname, "!, (@view p[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view p[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...)\n",
"    return hcat(sol.t, Array(sol)')\n",
"end \n\n",
"# Function for solving the ODEs with sensitivities\n",
"function solvesens_", modelname,"(p, times, solver::SciMLBase.AbstractODEAlgorithm, args...; kwargs...)\n",
"    sol = solve(ODEProblem(", modelname, "!, (@view p[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view p[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...)\n",
"    jac = reshape(ForwardDiff.jacobian(pars -> hcat(solve(ODEProblem(", modelname, "!, (@view pars[1:", as.character(length(dynvars)),"]), (times[1], times[end]), (@view pars[", as.character(length(dynvars)+1), ":end])), solver, args...; saveat=times, kwargs...).u...)', p),length(sol.t), :)\n",
"    return hcat(sol.t, Array(sol)',jac)\n",
"end \n\n"
)
# Save the generated Julia code to the specified file and source the code
writeLines(julia_code, file)
JuliaConnectoR::juliaEval(julia_code)
ODEmodel <- NULL
ODEmodel$solve <- function(x0, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6) {
# Integrate in Julia
out <- JuliaConnectoR::juliaLet(
paste0("solve_", modelname,"([x0;dynpars], times, ", solver, "; callback = cbs, tstops = tstop_events, abstol = atol, reltol = rtol)"),
x0 = x0, dynpars = dynpars, times = times, atol = atol, rtol = rtol
)
colnames(out) <- c("time", dynvars)
return(out)
}
ODEmodel$senssolve <- function(x0, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6) {
# Calculate Jacobian in Julia
out <- JuliaConnectoR::juliaLet(
paste0("solvesens_", modelname,"([x0;dynpars], times, ", solver, "; callback = cbs, tstops = tstop_events, abstol = atol, reltol = rtol)"),
x0 = x0, dynpars = dynpars, times = times, atol = atol, rtol = rtol
)
# Generate column names for the Jacobian
param_names <- c(dynvars, parameters)
jac_colnames <- c("time",dynvars, as.vector(outer(dynvars, param_names, paste, sep = ".")))
colnames(out) <- jac_colnames
return(out)
}
attr(ODEmodel, "equations") <- odefunction
attr(ODEmodel, "variables") <- dynvars
attr(ODEmodel, "parameters") <- parameters
attr(ODEmodel, "events") <- events
attr(ODEmodel, "modelname") <- modelname
attr(ODEmodel, "juliacode") <- julia_code
return(ODEmodel)
}
# Define an example ODE system (A -> B -> 0) with rates k1 and k2
odefunction <- list(
A = "-k1 * A",
B = "k1 * A - k2 * B"
)
events <- data.frame(var = c("A", "B"), time = c(50, 70), value = c(0.5, 0), method = c("add", "rep"))
# Generate the Julia model
odemodel <- juliaODEmodel(odefunction, modelname = "reaction_model")
# Initial conditions and parameters
inits <- c(A = 1, B = 0)
params <- c(k1 = 0.2, k2 = 0.1)
times <- seq(0, 100, length.out = 300)
# Solve the ODE system
out <- odemodel$solve(inits, params, times)
out_sens <- odemodel$solvesens(inits, params, times)
out_sens <- odemodel$senssolve(inits, params, times)
library(reshape2)
out <- melt(as.data.frame(out), id.vars = "time", variable.name = "name", value.name = "value")
out_sens <- melt(as.data.frame(out_sens), id.vars = "time", variable.name = "name", value.name = "value")
library(ggplot2)
# plotting the solution
ggplot(out, aes(x = time, y = value, color = name)) +
geom_line() +
facet_wrap(~ name, scales = "free_y") +
labs(
x = "time",
y = "value",
color = "Species"
) +
dMod::theme_dMod() +
dMod::scale_color_dMod()
# plotting the sensitivities
ggplot(out_sens, aes(x = time, y = value)) +
geom_line() +
facet_wrap(~ name, scales = "free_y") +
labs(
x = "time",
y = "Derivative value"
) +
dMod::theme_dMod() +
dMod::scale_color_dMod()
# Generate the Julia model
odemodel <- juliaODEmodel(odefunction, modelname = "reaction_model", events = events)
# Initial conditions and parameters
inits <- c(A = 1, B = 0)
params <- c(k1 = 0.2, k2 = 0.1)
times <- seq(0, 100, length.out = 300)
# Solve the ODE system
out <- odemodel$solve(inits, params, times)
out_sens <- odemodel$senssolve(inits, params, times)
params <- c(k1 = 0.1, k2 = 0.1)
times <- seq(0, 100, length.out = 300)
# Solve the ODE system
out <- odemodel$solve(inits, params, times)
out_sens <- odemodel$senssolve(inits, params, times)
# Initial conditions and parameters
inits <- c(A = 1, B = 0)
params <- c(k1 = 0.2, k2 = 0.1)
times <- seq(0, 100, length.out = 300)
# Solve the ODE system
out <- odemodel$solve(inits, params, times)
out_sens <- odemodel$senssolve(inits, params, times)
library(reshape2)
out <- melt(as.data.frame(out), id.vars = "time", variable.name = "name", value.name = "value")
out_sens <- melt(as.data.frame(out_sens), id.vars = "time", variable.name = "name", value.name = "value")
library(ggplot2)
# plotting the solution
ggplot(out, aes(x = time, y = value, color = name)) +
geom_line() +
facet_wrap(~ name, scales = "free_y") +
labs(
x = "time",
y = "value",
color = "Species"
) +
dMod::theme_dMod() +
dMod::scale_color_dMod()
# plotting the sensitivities
ggplot(out_sens, aes(x = time, y = value)) +
geom_line() +
facet_wrap(~ name, scales = "free_y") +
labs(
x = "time",
y = "Derivative value"
) +
dMod::theme_dMod() +
dMod::scale_color_dMod()
# Define an example ODE system (A -> B -> 0) with rates k1 and k2
odefunction <- list(
Prey = "alpha * Prey - beta * Prey * Predator",
Predator = "delta * Prey * Predator - gamma * Predator"
)
# Generate the Julia model
odemodel <- juliaODEmodel(odefunction, modelname = "LotkaVolterra")
# Initial conditions and parameters
inits <- c(Prey = 40, Predator = 9)
params <- c(alpha = 0.1, beta = 0.02, delta = 0.01, gamma = 0.1)
times <- seq(0, 200, length.out = 500)
# Solve the ODE system
out <- odemodel$solve(inits, params, times, solver = "Tsit5()")
jac <- odemodel$senssolve(inits, params, times, solver = "Tsit5()")
library(reshape2)
out <- melt(as.data.frame(out), id.vars = "time", variable.name = "name", value.name = "value")
jac <- melt(as.data.frame(jac), id.vars = "time", variable.name = "name", value.name = "value")
library(ggplot2)
# plotting the solution
ggplot(out, aes(x = time, y = value, color = name)) +
geom_line() +
facet_wrap(~ name, scales = "free_y") +
labs(
x = "time",
y = "value",
color = "Species"
) +
dMod::theme_dMod() +
dMod::scale_color_dMod()
# plotting the sensitivities
ggplot(jac, aes(x = time, y = value)) +
geom_line() +
facet_wrap(~ name, scales = "free_y") +
labs(
x = "time",
y = "Derivative value"
) +
dMod::theme_dMod() +
dMod::scale_color_dMod()
