% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/JuliaODE.R
\name{juliaODEmodel}
\alias{juliaODEmodel}
\title{Generate Julia Code for ODE Models}
\usage{
juliaODEmodel(
  odefunction,
  modelname = "odemodel",
  file = paste0(modelname, ".jl"),
  events = NULL
)
}
\arguments{
\item{odefunction}{A named list where names are the dynamic variables and values are the corresponding ODEs written as strings.}

\item{modelname}{A character string specifying the name of the generated Julia model function. Default is \code{"odemodel"}.}

\item{file}{A character string specifying the filename where the generated Julia code will be saved. Default is constructed as \code{paste0(modelname, ".jl")}.}

\item{events}{An optional data frame specifying events to occur at certain times. It must contain the columns: \code{"var"}, \code{"time"}, \code{"value"}, and \code{"method"}. The \code{"value"} column can contain expressions involving dynamic variables and parameters (e.g., \code{"0.5 * A"}, \code{"k2"}).}
}
\value{
An object with attributes:
\itemize{
\item \code{"equations"}: The ODE equations passed to the function.
\item \code{"variables"}: The dynamic variables in the system.
\item \code{"parameters"}: The parameters in the system.
\item \code{"events"}: The events data frame, if provided.
\item \code{"modelname"}: The name of the generated Julia model.
\item \code{"juliacode"}: The generated Julia code.
}

The returned object contains two methods:
\itemize{
\item \verb{$solve(inits, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6, maxsteps = 1e5)}: Solves the ODE system.
\item \verb{$senssolve(inits, dynpars, times, solver = "AutoTsit5(Rosenbrock32())", atol = 1e-8, rtol = 1e-6, maxsteps = 1e5)}: Solves the ODE system and computes sensitivities (Jacobian).
}
}
\description{
This function generates Julia code to solve ordinary differential equation (ODE) models
\deqn{\displaystyle \frac{dx}{dt} = f(x, p)\,, \quad x(t = t_0) = x_0(p)\,,}
along with supporting functions for integration and Jacobian computation. The function
automatically translates an equation list into Julia syntax and writes the resulting code
to a file. It also creates an interface for solving ODEs and computing the Jacobian
\deqn{\displaystyle \frac{\partial x}{\partial p}}
from R using the JuliaConnectoR package.
}
\examples{
\dontrun{
# Define ODE system
odefunction <- list(
  Prey = "alpha * Prey - beta * Prey * Predator",
  Predator = "delta * Prey * Predator - gamma * Predator"
)

# Define events
events <- data.frame(
  var = c("Prey", "Predator"),
  time = c(50, 100),
  value = c("2 * Prey", "Predator / 2"),
  method = c("add", "rep")
)

# Generate the Julia model
odemodel <- juliaODEmodel(odefunction, modelname = "LotkaVolterra", events = events)

# Initial conditions and parameters
inits <- c(Prey = 40, Predator = 9)
params <- c(alpha = 0.1, beta = 0.02, delta = 0.01, gamma = 0.1)
times <- seq(0, 200, length.out = 500)

# Solve the ODE system without sensitivities
solution <- odemodel$solve(inits, params, times)
print(head(solution))

# Solve the ODE system with sensitivities
solution_sens <- odemodel$senssolve(inits, params, times)
print(head(solution_sens))
}
}
